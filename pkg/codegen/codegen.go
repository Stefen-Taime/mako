// Package codegen generates deployment artifacts from pipeline specs.
//
// pipeline.yaml → K8s manifests + Terraform HCL.
package codegen

import (
	"bytes"
	"fmt"
	"strings"
	"text/template"

	v1 "github.com/Stefen-Taime/mako/api/v1"
)

// GenerateK8s generates Kubernetes deployment manifests for a pipeline.
func GenerateK8s(spec *v1.PipelineSpec, registry string) (string, error) {
	p := spec.Pipeline

	replicas := 1
	cpu := "200m"
	memory := "256Mi"
	if p.Resources != nil {
		if p.Resources.Replicas > 0 {
			replicas = p.Resources.Replicas
		}
		if p.Resources.CPU != "" {
			cpu = p.Resources.CPU
		}
		if p.Resources.Memory != "" {
			memory = p.Resources.Memory
		}
	}

	data := map[string]any{
		"Name":          p.Name,
		"Namespace":     "mako",
		"Registry":      registry,
		"Replicas":      replicas,
		"CPU":           cpu,
		"Memory":        memory,
		"SourceType":    string(p.Source.Type),
		"SourceTopic":   p.Source.Topic,
		"ConsumerGroup": p.Source.ConsumerGroup,
		"SinkType":      string(p.Sink.Type),
		"SinkTable":     p.Sink.Table,
		"Owner":         p.Owner,
		"Labels":        p.Labels,
		"HasMonitoring": p.Monitoring != nil,
		"HasAutoscale":  p.Resources != nil && p.Resources.Autoscale != nil && p.Resources.Autoscale.Enabled,
	}

	if p.Monitoring != nil {
		data["FreshnessSLA"] = p.Monitoring.FreshnessSLA
		data["AlertChannel"] = p.Monitoring.AlertChannel
	}
	if p.Resources != nil && p.Resources.Autoscale != nil {
		data["MinReplicas"] = p.Resources.Autoscale.MinReplicas
		data["MaxReplicas"] = p.Resources.Autoscale.MaxReplicas
	}

	var buf bytes.Buffer
	tmpl, err := template.New("k8s").Parse(k8sTemplate)
	if err != nil {
		return "", fmt.Errorf("parse template: %w", err)
	}
	if err := tmpl.Execute(&buf, data); err != nil {
		return "", fmt.Errorf("execute template: %w", err)
	}
	return buf.String(), nil
}

// GenerateTerraform generates Terraform HCL for pipeline infrastructure.
func GenerateTerraform(spec *v1.PipelineSpec) (string, error) {
	p := spec.Pipeline

	data := map[string]any{
		"Name":         p.Name,
		"NameUnder":    strings.ReplaceAll(p.Name, "-", "_"),
		"SourceTopic":  p.Source.Topic,
		"SinkType":     string(p.Sink.Type),
		"SinkDatabase": p.Sink.Database,
		"SinkSchema":   p.Sink.Schema,
		"SinkTable":    p.Sink.Table,
		"HasSchema":    p.Schema != nil && p.Schema.Enforce,
		"HasDLQ":       p.Isolation.DLQEnabled,
	}

	var buf bytes.Buffer
	tmpl, err := template.New("tf").Parse(terraformTemplate)
	if err != nil {
		return "", fmt.Errorf("parse template: %w", err)
	}
	if err := tmpl.Execute(&buf, data); err != nil {
		return "", fmt.Errorf("execute template: %w", err)
	}
	return buf.String(), nil
}

// ═══════════════════════════════════════════
// Templates
// ═══════════════════════════════════════════

const k8sTemplate = `# Generated by mako — do not edit manually
# Pipeline: {{ .Name }}
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Name }}-config
  namespace: {{ .Namespace }}
  labels:
    app.kubernetes.io/name: {{ .Name }}
    app.kubernetes.io/managed-by: mako
    mako.io/pipeline: {{ .Name }}
    {{- range $k, $v := .Labels }}
    {{ $k }}: "{{ $v }}"
    {{- end }}
data:
  PIPELINE_NAME: "{{ .Name }}"
  SOURCE_TYPE: "{{ .SourceType }}"
  SOURCE_TOPIC: "{{ .SourceTopic }}"
  CONSUMER_GROUP: "{{ .ConsumerGroup }}"
  SINK_TYPE: "{{ .SinkType }}"
  SINK_TABLE: "{{ .SinkTable }}"
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: {{ .Name }}
  namespace: {{ .Namespace }}
  labels:
    app.kubernetes.io/name: {{ .Name }}
    app.kubernetes.io/managed-by: mako
    mako.io/pipeline: {{ .Name }}
    {{- if .Owner }}
    mako.io/owner: "{{ .Owner }}"
    {{- end }}
spec:
  replicas: {{ .Replicas }}
  selector:
    matchLabels:
      app.kubernetes.io/name: {{ .Name }}
  template:
    metadata:
      labels:
        app.kubernetes.io/name: {{ .Name }}
        mako.io/pipeline: {{ .Name }}
      annotations:
        prometheus.io/scrape: "true"
        prometheus.io/port: "9090"
    spec:
      containers:
        - name: pipeline
          image: {{ .Registry }}/mako-runner:latest
          args: ["run", "--config", "/etc/mako/pipeline.yaml"]
          envFrom:
            - configMapRef:
                name: {{ .Name }}-config
          ports:
            - { containerPort: 9090, name: metrics }
          resources:
            requests:
              cpu: {{ .CPU }}
              memory: {{ .Memory }}
            limits:
              cpu: {{ .CPU }}
              memory: {{ .Memory }}
          livenessProbe:
            httpGet: { path: /healthz, port: 9090 }
            initialDelaySeconds: 10
          readinessProbe:
            httpGet: { path: /readyz, port: 9090 }
            initialDelaySeconds: 5
          volumeMounts:
            - { name: config, mountPath: /etc/mako }
      volumes:
        - name: config
          configMap:
            name: {{ .Name }}-config
---
apiVersion: v1
kind: Service
metadata:
  name: {{ .Name }}
  namespace: {{ .Namespace }}
spec:
  selector:
    app.kubernetes.io/name: {{ .Name }}
  ports:
    - { name: metrics, port: 9090, targetPort: 9090 }
{{- if .HasAutoscale }}
---
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: {{ .Name }}
  namespace: {{ .Namespace }}
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: {{ .Name }}
  minReplicas: {{ .MinReplicas }}
  maxReplicas: {{ .MaxReplicas }}
  metrics:
    - type: Pods
      pods:
        metric: { name: kafka_consumer_lag }
        target: { type: AverageValue, averageValue: "1000" }
{{- end }}
`

const terraformTemplate = `# Generated by mako — do not edit manually
# Pipeline: {{ .Name }}

# ── Kafka Topic ──
resource "kafka_topic" "{{ .NameUnder }}" {
  name               = "{{ .SourceTopic }}"
  replication_factor = 3
  partitions         = 6

  config = {
    "retention.ms"  = "604800000" # 7 days
    "cleanup.policy" = "delete"
  }
}
{{ if .HasDLQ }}
resource "kafka_topic" "{{ .NameUnder }}_dlq" {
  name               = "{{ .SourceTopic }}.dlq"
  replication_factor = 3
  partitions         = 3

  config = {
    "retention.ms" = "2592000000" # 30 days
  }
}
{{ end }}
{{ if eq .SinkType "snowflake" }}
# ── Snowflake Objects ──
resource "snowflake_table" "{{ .NameUnder }}" {
  database = "{{ .SinkDatabase }}"
  schema   = "{{ .SinkSchema }}"
  name     = "{{ .SinkTable }}"
  
  column {
    name = "EVENT_ID"
    type = "VARCHAR(255)"
  }
  column {
    name = "EVENT_DATA"
    type = "VARIANT"
  }
  column {
    name = "LOADED_AT"
    type = "TIMESTAMP_NTZ"
  }
}

resource "snowflake_pipe" "{{ .NameUnder }}" {
  database = "{{ .SinkDatabase }}"
  schema   = "{{ .SinkSchema }}"
  name     = "{{ .SinkTable }}_PIPE"
  
  copy_statement = "COPY INTO {{ .SinkDatabase }}.{{ .SinkSchema }}.{{ .SinkTable }} FROM @{{ .SinkDatabase }}.{{ .SinkSchema }}.MAKO_STAGE"
  auto_ingest    = true
}
{{ end }}
{{ if eq .SinkType "bigquery" }}
# ── BigQuery Objects ──
resource "google_bigquery_table" "{{ .NameUnder }}" {
  dataset_id = "{{ .SinkSchema }}"
  table_id   = "{{ .SinkTable }}"
  
  time_partitioning {
    type  = "DAY"
    field = "loaded_at"
  }

  labels = {
    pipeline   = "{{ .Name }}"
    managed_by = "mako"
  }
}
{{ end }}
{{ if .HasSchema }}
# ── Schema Registry ──
resource "confluent_schema" "{{ .NameUnder }}" {
  subject_name = "{{ .SourceTopic }}-value"
  format       = "PROTOBUF"
  
  schema_registry_cluster {
    id = var.schema_registry_id
  }
}
{{ end }}
`
